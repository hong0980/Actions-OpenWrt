name: 清理 release tag

on:
  workflow_dispatch:
    inputs:
      keep_latest:
        description: '保留最新的N个release (默认20)'
        required: false
        default: '20'
      skip_confirmation:
        description: '跳过确认直接执行 (true/false)'
        required: false
        default: 'false'
  schedule:
    - cron: '0 20 * * 6'  # 每周六UTC时间20点自动运行(北京时间周日4点)

jobs:
  cleanup:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # 设置15分钟超时
    permissions:
      contents: write
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置Python环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: 安装Python依赖
        run: |
          pip install PyGithub
          pip install click

      - name: 执行清理
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          KEEP_LATEST: ${{ inputs.keep_latest || 20 }}
          SKIP_CONFIRM: ${{ inputs.skip_confirmation || 'false' }}
          IS_SCHEDULED: ${{ github.event_name == 'schedule' }}
        run: |
          python - <<EOF
          from github import Github
          import os
          import sys
          from datetime import datetime
          try:
              import click
          except ImportError:
              print("❌ Click包未安装，请确保前置步骤已安装依赖")
              sys.exit(1)

          # 配置参数
          REPO_NAME = os.getenv('GITHUB_REPOSITORY', 'hong0980/Actions-OpenWrt')
          TARGET_PATTERNS = ["openwrt", "coolsnowwolf", "immortalwrt"]

          # 获取环境变量
          keep_latest = int(os.getenv('KEEP_LATEST', 20))
          skip_confirm = os.getenv('SKIP_CONFIRM', 'false').lower() == 'true'
          is_scheduled = os.getenv('IS_SCHEDULED', 'false').lower() == 'true'

          # 初始化GitHub客户端
          gh = Github(os.getenv('GITHUB_TOKEN'))
          repo = gh.get_repo(REPO_NAME)

          def parse_tag_date(tag):
              """安全解析标签日期"""
              try:
                  date_part = '-'.join(tag.split('-')[:3])
                  return datetime.strptime(date_part, "%Y-%m-%d")
              except (ValueError, IndexError):
                  return None

          # 收集符合条件的release
          candidates = []
          for release in repo.get_releases():
              tag = release.tag_name
              if not any(p in tag for p in TARGET_PATTERNS):
                  continue

              if (date := parse_tag_date(tag)):
                  candidates.append((date, release, tag))

          if not candidates:
              print("ℹ️ 没有找到符合条件的releases")
              sys.exit(0)

          # 按日期排序
          candidates.sort(key=lambda x: x[0], reverse=True)

          # 分割保留/删除列表
          keep = candidates[:keep_latest]
          delete = candidates[keep_latest:]

          # 生成报告
          print("\n📝 清理计划报告:")
          print(f"• 仓库: {REPO_NAME}")
          print(f"• 找到 {len(candidates)} 个符合条件的releases")
          print(f"• 将保留最新的 {len(keep)} 个releases:")
          for i, (date, _, tag) in enumerate(keep, 1):
              print(f"  {i}. {tag} ({date.date()})")

          print(f"\n• 将删除 {len(delete)} 个旧releases:")
          for date, _, tag in delete:
              print(f"  - {tag} ({date.date()})")

          print(f"\n• 当前模式: {'定时任务' if is_scheduled else '手动触发'}")

          # 确认流程 (非定时任务且未跳过确认时)
          if not is_scheduled and not skip_confirm:
              if not click.confirm('\n⚠️ 确认要执行删除操作吗?', default=False):
                  print("🛑 用户取消操作")
                  sys.exit(0)

          # 实际删除操作
          deleted_count = 0
          for date, release, tag in delete:
              try:
                  print(f"\n🗑️ 处理 {tag}...")
                  release.delete_release()
                  repo.get_git_ref(f"tags/{tag}").delete()
                  print(f"✅ 已删除 {tag}")
                  deleted_count += 1
              except Exception as e:
                  print(f"❌ 删除失败: {str(e)}")

          # 结果摘要
          print("\n📊 清理结果摘要:")
          print(f"• 尝试删除: {len(delete)} 个releases")
          print(f"• 成功删除: {deleted_count} 个")
          print(f"• 失败: {len(delete) - deleted_count} 个")
          print(f"• 最终保留: {len(keep)} 个最新releases")
          EOF
