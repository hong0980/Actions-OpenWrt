name: æ¸…ç† OpenWrt Releases å’Œ Tags

on:
  workflow_dispatch:
    inputs:
      keep_per_type:
        description: 'æ¯ç§ç±»å‹ä¿ç•™çš„æœ€æ–°releaseæ•°é‡ (é»˜è®¤20)'
        required: false
        default: '20'
      confirm_delete:
        description: 'å¿…é¡»è®¾ç½®ä¸º "CONFIRM" æ‰ä¼šå®é™…æ‰§è¡Œåˆ é™¤'
        required: true
        default: 'CONFIRM'
  schedule:
    - cron: '0 20 15 * *'

jobs:
  delete-Releases-Tags:
    runs-on: ubuntu-latest
    env:
          TZ: Asia/Shanghai
    permissions:
      contents: write
    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v6

      - name: è®¾ç½®Pythonç¯å¢ƒ
        uses: actions/setup-python@v6.2.0
        with:
          python-version: '3.13'

      - name: å®‰è£…ä¾èµ–
        run: pip install PyGithub requests

      - name: æ‰§è¡Œæ¸…ç†
        env:
          REPO_NAME: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
          KEEP_PER_TYPE: ${{ inputs.keep_per_type || 20 }}
          CONFIRM_DELETE: ${{ inputs.confirm_delete || 'DRY-RUN' }}
        run: |
          python - <<EOF
          import os, sys, time, requests
          from datetime import datetime
          from collections import defaultdict
          from github import Auth, Github, GithubException

          # é…ç½®
          REPO_NAME = os.getenv('REPO_NAME')
          GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')
          KEEP = int(os.getenv('KEEP_PER_TYPE', 20))
          CONFIRM = os.getenv('CONFIRM_DELETE') == 'CONFIRM'
          TARGET_TYPES = {
              'openwrt': ['openwrt'],
              'immortalwrt': ['immortalwrt'],
              'coolsnowwolf': ['coolsnowwolf']
          }
          HEADERS = {
              "Authorization": f"token {GITHUB_TOKEN}",
              "Accept": "application/vnd.github.v3+json",
              "User-Agent": "hong0980/Actions-OpenWrt-Cleanup"
          }

          def parse_date(tag_name):
              """ä» tag åè§£ææ—¥æœŸï¼Œå¤±è´¥æ—¶è¿”å›è¿œå¤æ—¥æœŸ"""
              try:
                  parts = tag_name.split('-')
                  if len(parts) >= 3:
                      return datetime.strptime('-'.join(parts[:3]), "%Y-%m-%d")
              except ValueError:
                  pass
              return datetime(1970, 1, 1)

          def get_release_type(tag_name):
              """æ£€æŸ¥ tag æ˜¯å¦ä»¥ç›®æ ‡ç±»å‹å¼€å¤´"""
              for type_name, patterns in TARGET_TYPES.items():
                  if any(p in tag_name for p in patterns):
                      return type_name
              return None

          def delete_tag(tag_name, failed_items):
              """åˆ é™¤ tag"""
              url = f"https://api.github.com/repos/{REPO_NAME}/git/refs/tags/{tag_name}"
              headers = HEADERS
              response = requests.get(url, headers=headers)
              if response.status_code == 200:
                  tag_data = response.json()
                  tag_type = 'annotated' if tag_data['object']['type'] == 'tag' else 'lightweight'
              else:
                  print(f"ğŸ” tag {tag_name} ä¸å­˜åœ¨ (çŠ¶æ€ç : {response.status_code})")
                  return False
              for attempt in range(3):
                  try:
                      response = requests.delete(url, headers=headers)
                      if response.status_code in (204, 200):
                          print(f"âœ… å·²åˆ é™¤ tag: {tag_name}")
                          return True
                      print(f"âŒ åˆ é™¤ tag å¤±è´¥ (å°è¯• {attempt + 1}/3): {tag_name} (çŠ¶æ€ç : {response.status_code}, å“åº”: {response.text})")
                      time.sleep(1)
                  except Exception as e:
                      print(f"âŒ åˆ é™¤ tag å¤±è´¥ (å°è¯• {attempt + 1}/3): {tag_name} ({str(e)})")
                      time.sleep(1)
              failed_items.append(('tag', tag_name))
              print(f"æ‰‹åŠ¨åˆ é™¤å‘½ä»¤: gh api -X DELETE /repos/{REPO_NAME}/git/refs/tags/{tag_name}")
              return False

          def main():
              """ä¸»æ¸…ç†é€»è¾‘"""
              if not GITHUB_TOKEN:
                  print("âŒ é”™è¯¯: GITHUB_TOKEN æœªè®¾ç½®")
                  sys.exit(1)

              # æ£€æŸ¥ API é™é¢
              try:
                  response = requests.get("https://api.github.com/rate_limit", headers=HEADERS, timeout=10)
                  if response.status_code == 200:
                      remaining = response.json()['rate']['remaining']
                      print(f"ğŸ“Š API é™é¢å‰©ä½™: {remaining}")
                      if remaining < 50:
                          print("âš ï¸ API é™é¢ä¸è¶³")
                          sys.exit(1)
                  else:
                      print(f"âš ï¸ API é™é¢æ£€æŸ¥å¤±è´¥: çŠ¶æ€ç  {response.status_code}")
              except Exception as e:
                  print(f"âš ï¸ API é™é¢æ£€æŸ¥å‡ºé”™: {str(e)}")

              gh = Github(auth=Auth.Token(GITHUB_TOKEN))
              repo = gh.get_repo(REPO_NAME)
              failed_items = []
              deleted_count = 0

              # è·å–æ‰€æœ‰ releases
              releases_by_type = defaultdict(list)
              for release in repo.get_releases():
                  tag = release.tag_name
                  if tag.endswith('-Cache'):
                      continue
                  if release_type := get_release_type(tag):
                      date = parse_date(tag)
                      releases_by_type[release_type].append((date, release, tag))

              if not releases_by_type:
                  print("â„¹ï¸ æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„ releases")
                  sys.exit(0)

              # ç¡®å®šè¦åˆ é™¤çš„ releases
              to_delete_releases = []
              for release_type, releases in releases_by_type.items():
                  releases.sort(key=lambda x: x[0], reverse=True)
                  keep = releases[:KEEP]
                  delete = releases[KEEP:]
                  print(f"\nğŸ”µ {release_type} ç±»å‹:")
                  print(f"â€¢ ä¿ç•™æœ€æ–°çš„ {len(keep)} ä¸ª:")
                  for i, (date, _, tag) in enumerate(keep, 1):
                      print(f"  {i}. {tag} ({date.date()})")
                  if delete:
                      print(f"â€¢ å°†åˆ é™¤ {len(delete)} ä¸ªæ—§çš„ releases:")
                      for date, _, tag in delete:
                          print(f"{tag} ({date.date()})")
                      to_delete_releases.extend(delete)
                  else:
                      print("â€¢ æ— éœ€åˆ é™¤ releases (æ•°é‡æœªè¶…è¿‡ä¿ç•™é™åˆ¶)")

              if not to_delete_releases:
                  print("\nğŸŸ¢ æ²¡æœ‰éœ€è¦åˆ é™¤çš„ releases æˆ– tags")
                  sys.exit(0)

              if not CONFIRM:
                  print("\nğŸ›‘ è¯•è¿è¡Œå®Œæˆï¼Œå¦‚éœ€å®é™…åˆ é™¤è¯·è®¾ç½® confirm_delete=CONFIRM")
                  sys.exit(0)

              # åˆ é™¤ releases å’Œ tags
              for date, release, tag in to_delete_releases:
                  try:
                      print(f"\nğŸ—‘ åˆ é™¤ {tag}")
                      release.delete_release()
                      print(f"âœ… å·²åˆ é™¤ release: {tag}")
                      deleted_count += 1
                  except GithubException as e:
                      print(f"âŒ åˆ é™¤ release å¤±è´¥: {tag} ({e.data.get('message', str(e))})")
                      failed_items.append(('release', tag))
                      continue
                  if delete_tag(tag, failed_items):
                      deleted_count += 1

              print(f"\nğŸ“Š åˆ é™¤ç»“æœ: {deleted_count}/{len(to_delete_releases) * 2} æˆåŠŸ")
              if failed_items:
                  print("\nâš ï¸ ä»¥ä¸‹ release/tag éœ€è¦æ‰‹åŠ¨åˆ é™¤:")
                  for item_type, item in failed_items:
                      print(f"{item_type}: {item}")
                      if item_type == 'tag':
                          print(f"æ‰‹åŠ¨åˆ é™¤å‘½ä»¤: gh api -X DELETE /repos/{REPO_NAME}/git/refs/tags/{item}")

          if __name__ == "__main__":
              main()
          EOF
