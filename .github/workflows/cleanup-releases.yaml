name: 清理 release 和 tag

on:
  workflow_dispatch:
    inputs:
      keep_latest:
        description: '保留最新的N个release (默认20)'
        required: false
        default: '20'
      confirm_delete:
        description: '必须设置为"CONFIRM"才会实际执行删除'
        required: true
        default: 'DRY-RUN'
  schedule:
    - cron: '0 20 * * 6'  # 每周六UTC时间20点自动运行

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # 必须要有写权限
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置Python环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: 安装依赖
        run: pip install PyGithub

      - name: 执行清理
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          KEEP_LATEST: ${{ inputs.keep_latest || 20 }}
          CONFIRM_DELETE: ${{ inputs.confirm_delete || 'DRY-RUN' }}
        run: |
          python - <<EOF
          from github import Github, GithubException
          import os
          import sys
          from datetime import datetime

          # 配置
          REPO_NAME = os.getenv('GITHUB_REPOSITORY')
          TARGET_PATTERNS = ["openwrt", "coolsnowwolf", "immortalwrt"]
          KEEP = int(os.getenv('KEEP_LATEST', 20))
          CONFIRM = os.getenv('CONFIRM_DELETE') == 'CONFIRM'

          # 初始化
          gh = Github(os.getenv('GITHUB_TOKEN'))
          repo = gh.get_repo(REPO_NAME)

          def should_keep(tag_name):
              return any(p in tag_name for p in TARGET_PATTERNS)

          def parse_date(tag_name):
              try:
                  return datetime.strptime('-'.join(tag_name.split('-')[:3]), "%Y-%m-%d")
              except:
                  return None

          # 收集releases
          releases = []
          for release in repo.get_releases():
              tag = release.tag_name
              if not should_keep(tag):
                  continue
              if date := parse_date(tag):
                  releases.append((date, release, tag))

          if not releases:
              print("ℹ️ 没有找到符合条件的releases")
              sys.exit(0)

          # 排序
          releases.sort(key=lambda x: x[0], reverse=True)

          # 分割
          keep = releases[:KEEP]
          delete = releases[KEEP:]

          # 打印计划
          print(f"将保留 {len(keep)} 个最新releases:")
          for i, (date, _, tag) in enumerate(keep, 1):
              print(f"  {i}. {tag}")

          print(f"\n将删除 {len(delete)} 个旧releases和tags:")
          for _, _, tag in delete:
              print(f"  - {tag}")

          if not CONFIRM:
              print("\n🛑 试运行模式，如需实际删除请设置 confirm_delete=CONFIRM")
              sys.exit(0)

          # 实际删除
          failed_tags = []
          for _, release, tag in delete:
              try:
                  # 1. 先删除release
                  print(f"\n🗑 删除release: {tag}")
                  release.delete_release()

                  # 2. 删除tag (正确的ref路径)
                  try:
                      print(f"🗑 删除tag: {tag}")
                      repo.get_git_ref(f"refs/tags/{tag}").delete()
                  except GithubException as e:
                      if e.status == 404:
                          print(f"⚠️ tag {tag} 不存在(可能已被删除)")
                      else:
                          print(f"❌ 删除tag失败: {e.data.get('message', str(e))}")
                          failed_tags.append(tag)
              except Exception as e:
                  print(f"❌ 删除失败: {str(e)}")
                  failed_tags.append(tag)

          # 结果报告
          success = len(delete) - len(failed_tags)
          print(f"\n✅ 成功删除 {success}/{len(delete)} 个release和tag")
          if failed_tags:
              print("\n⚠️ 以下tag删除失败，可能需要手动删除:")
              for tag in failed_tags:
                  print(f"  - {tag}")
                  print(f"    手动删除命令: gh api -X DELETE /repos/{REPO_NAME}/git/refs/tags/{tag}")
          EOF
